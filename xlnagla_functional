#pragma once

#include <tuple>
#include <algorithm>
#include <numeric>
#include <list>
#include <iterator>

#include "memoize.h"

namespace xlnagla{


//this is better as a macro
//the base case is the first argument.
	template<typename T>
		inline const T& cond(bool acond, const T& res, const T& basecase){
		return acond ? res : basecase;
	}
	
	template<typename T, typename... L>
		inline const T& cond(bool acond, const T& res, const L&... l){
		return acond ? res : cond(l...);
	}

	template<typename T, typename B>
		inline const T&	lazy_cond(const B &acond, const T &res, const T& basecase){
		return *acond ? res : basecase;
	}

	template<typename T, typename B, typename... L>
		inline const T& lazy_cond(const B& acond, const T& res, const L&... l){
		return *acond ? res : lazy_cond(l...);
	}

	template<typename R, typename A, typename... B>
		inline const std::function< std::function<R (B...)> (A) > curry(std::function<R (A, B...)> f){
		return [f](A a){
			return [a, f](B... b){
				return f(a, b...);
			};
		};
	}

//because irritatingly enough trying to pass a lambda to something that expects a 
//function of the same type will not work.  grr.  This only works on functions 
//of no arguments.
#define CONVERT_TO_STD_FUNCTION(lambda) [&](){\
		auto f = std::move(lambda);\
		typedef decltype(f) f_type;\
		typedef std::result_of<f_type()>::type rettype;	\
		std::function<rettype () > retf = std::move(f);	\
		return std::move(retf);						\
	}()


	template<typename T, typename A, typename L>
		std::list<T> map(std::function<T (A)> f, const L& list){
		std::list<T> ret;
		std::transform(std::begin(list), std::end(list),std::back_inserter(ret), f);
		return std::move(ret);
	}

	template<typename T, typename A>
		std::list<T> map(std::function<T (A)> f, const std::initializer_list<A>& list){
		std::list<T> ret;
		std::transform(std::begin(list), std::end(list),std::back_inserter(ret), f);
		return std::move(ret);
	}

	template<typename T, typename L>
		T foldl(std::function<T (T, T) > f, const L& list, T t = T()){
		return std::accumulate(std::begin(list), std::end(list), t, f);
	}
	template<typename T>
		T foldl(std::function<T (T, T) > f, const std::initializer_list<T>& list, T t = T()){
		return std::accumulate(std::begin(list), std::end(list), t, f);
	}


	/*
currying: T f(a,b) -> T f(a)(b)

that means it's implemented something like this:

std::function< std::function<T (b) > (a) >curry( function<T (a,b)> f){

//close over f, takes an a
return [f](a){
  return [a,f](b){
    return f(a,b);
}
}

}
	 */

}
